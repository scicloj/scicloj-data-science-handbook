<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script id="state" type="text">"{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :initially-collapse? false, :auto-scroll? false, :port 1903, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Fri Jul 16 14:47:20 IDT 2021\"] nil [:hr]], :custom-footer [:div [:hr] [:hr]]}, :ids [\"1530\" \"1691\" \"1692\" \"1693\" \"1694\" \"1695\" \"1696\" \"1697\" \"1538\" \"1698\" \"1540\" \"1699\" \"1542\" \"1543\" \"1700\" \"1545\" \"1546\" \"1701\" \"1548\" \"1702\" \"1703\" \"1704\" \"1705\" \"1706\" \"1554\" \"1555\" \"1707\" \"1708\" \"1709\" \"1710\" \"1711\" \"1712\" \"1562\" \"1713\" \"1564\" \"1714\" \"1566\" \"1715\" \"1716\" \"1569\" \"1717\" \"1718\" \"1719\" \"1720\" \"1721\" \"1722\" \"1723\" \"1724\" \"1725\" \"1726\" \"1727\" \"1728\" \"1729\" \"1730\" \"1731\" \"1732\" \"1733\" \"1734\" \"1735\" \"1736\" \"1737\" \"1738\" \"1739\" \"1740\" \"1594\" \"1741\" \"1742\" \"1743\" \"1744\" \"1745\" \"1746\" \"1747\" \"1748\" \"1749\" \"1604\" \"1750\" \"1751\" \"1752\" \"1753\" \"1754\" \"1755\" \"1611\" \"1756\" \"1757\" \"1758\" \"1615\" \"1759\" \"1760\" \"1761\" \"1762\" \"1763\" \"1764\" \"1765\" \"1766\" \"1767\" \"1768\" \"1769\" \"1770\" \"1771\" \"1772\" \"1773\" \"1774\" \"1775\" \"1776\" \"1777\" \"1778\" \"1779\" \"1780\" \"1781\" \"1782\" \"1783\" \"1784\" \"1785\" \"1786\" \"1787\" \"1788\" \"1789\" \"1790\" \"1791\" \"1792\" \"1793\" \"1794\" \"1795\" \"1796\" \"1797\" \"1798\" \"1799\" \"1800\" \"1801\" \"1802\" \"1803\" \"1804\" \"1805\" \"1806\" \"1807\" \"1808\" \"1809\" \"1810\" \"1811\" \"1812\" \"1813\" \"1814\" \"1815\" \"1816\" \"1817\" \"1818\" \"1819\" \"1820\" \"1821\" \"1822\" \"1823\" \"1824\" \"1825\" \"1826\" \"1827\" \"1828\"], :id->content {\"1803\" [:div [:p] [:div [:p/code {:code \"(nd-reduce 1 + m)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[2 5]\\n[[15 18 21 24 27]\\n [60 63 66 69 72]]\\n\"}]], \"1717\" [:div [:p] [:div [:p/code {:code \"(defn eye [n]\\n  (letfn [(= [a b] (if (clojure.core/= a b) 1 0))]\\n    (outer-product = (dtt/->tensor (range n))\\n                   (dtt/->tensor (range n)))))\", :bg-class \"bg-light\"}]] nil nil], \"1819\" [:div [:p] nil nil [:p/markdown \"Comparisons, Masks, and Boolean Logic\\n ------------------------------------------------\"]], \"1825\" [:div [:p] nil nil [:p/markdown \"Example: use mask and compress to select all letters at even positions\"]], \"1569\" [:div [:p] [:div [:p/code {:code \"(defn outer-product\\n  ;; Author: Chris Nuernberger\\n  ;; https://github.com/scicloj/scicloj-data-science-handbook/pull/2#discussion_r548033202\\n  [f a b]\\n  (let [a-shape (dtype/shape a)\\n        b-shape (dtype/shape b)\\n        a-rdr   (dtype/->reader a)\\n        b-rdr   (dtype/->reader b)\\n        n-b     (.lsize b-rdr)\\n        n-elems (* (.lsize a-rdr) n-b)]\\n    ;;Doing the cartesian join is easier in linear space\\n    (-> (dtype/emap\\n         (fn [^long idx]\\n           (let [a-idx (quot idx n-b)\\n                 b-idx (rem idx n-b)]\\n             (f (a-rdr a-idx) (b-rdr b-idx))))\\n         :object\\n         (range n-elems))\\n        (dtt/reshape (concat a-shape b-shape)))))\", :bg-class \"bg-light\"}]] nil nil], \"1757\" [:div [:p] [:div [:p/code {:code \"(concatenate 1 t235 t235)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[2 6 5]\\n[[[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]\\n  [ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]\\n  [15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]]\\n\"}]], \"1712\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (fn [_] (fm.rand/grand 0 1)) nil\\n            (dtt/new-tensor [3 3]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[3 3]\\n[[ 0.6057  0.2362 -0.6650]\\n [ 0.5020  0.5935 -0.1841]\\n [-0.6595   1.256  0.4194]]\\n\"}]], \"1807\" [:div [:p] [:div [:p/code {:code \"(nd-reduce 2 + m)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[2 3]\\n[[10  35  60]\\n [85 110 135]]\\n\"}]], \"1813\" [:div [:p] nil nil [:p/markdown \"### Example: What is the Average Height of US Presidents?\\n\\n```\\nimport pandas as pd\\ndata = pd.read_csv('data/president_heights.csv')\\nheights = np.array(data['height(cm)'])\\nprint(\\\"Mean height:       \\\", heights.mean())\\nprint(\\\"Standard deviation\\\", heights.std())\\nprint(\\\"Minimum height:    \\\", heights.min())\\nprint(\\\"Maximum height:    \\\", heights.max())\\n\\nprint(\\\"25th percentile:   \\\", np.percentile(heights, 25))\\nprint(\\\"Median:            \\\", np.median(heights))\\nprint(\\\"75th percentile:   \\\", np.percentile(heights, 75))\\n\\n%matplotlib inline\\nimport matplotlib.pyplot as plt\\nimport seaborn; seaborn.set()  # set plot style\\nplt.hist(heights)\\nplt.title('Height Distribution of US Presidents')\\nplt.xlabel('height (cm)')\\nplt.ylabel('number'));\\n```\"]], \"1753\" [:div [:p] [:div [:p/code {:code \"(nth (dtype/shape t23) (dec 2))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"3\\n\"}]], \"1815\" [:div [:p] [:div [:p/code {:code \"^k/dataset\\n(ds/head csv-data 3)\", :bg-class \"bg-light\"}]] nil [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"230px\"}} [:p/markdown \"https://raw.githubusercontent.com/jakevdp/PythonDataScienceHandbook/master/notebooks/data/president_heights.csv [3 3]:\\n\\n| order |              name | height(cm) |\\n|------:|-------------------|-----------:|\\n|     1 | George Washington |        189 |\\n|     2 |        John Adams |        170 |\\n|     3 |  Thomas Jefferson |        189 |\\n\"]]], \"1796\" [:div [:p] [:div [:p/code {:code \"(let [f +] \\n  (dtt/->tensor \\n   [[(f (dtt/mget m 0 0 0) (dtt/mget m 1 0 0)) (f (dtt/mget m 0 0 1) (dtt/mget m 1 0 1)) (f (dtt/mget m 0 0 2) (dtt/mget m 1 0 2)) (f (dtt/mget m 0 0 3) (dtt/mget m 1 0 3)) (f (dtt/mget m 0 0 4) (dtt/mget m 1 0 4))]\\n    [(f (dtt/mget m 0 1 0) (dtt/mget m 1 1 0)) (f (dtt/mget m 0 1 1) (dtt/mget m 1 1 1)) (f (dtt/mget m 0 1 2) (dtt/mget m 1 1 2)) (f (dtt/mget m 0 1 3) (dtt/mget m 1 1 3)) (f (dtt/mget m 0 1 4) (dtt/mget m 1 1 4))]\\n    [(f (dtt/mget m 0 2 0) (dtt/mget m 1 2 0)) (f (dtt/mget m 0 2 1) (dtt/mget m 1 2 1)) (f (dtt/mget m 0 2 2) (dtt/mget m 1 2 2)) (f (dtt/mget m 0 2 3) (dtt/mget m 1 2 3)) (f (dtt/mget m 0 2 4) (dtt/mget m 1 2 4))]]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[3 5]\\n[[15 17 19 21 23]\\n [25 27 29 31 33]\\n [35 37 39 41 43]]\\n\"}]], \"1776\" [:div [:p] nil nil [:p/markdown \"#### Exponents and logarithms\\n\\n* e^x, 2^x, n^x\\n* ln(x), log2(x), log10(x)\\n* np.expm1(x) = exp(x) - 1, np.log1p(x) = log(1 + x)\"]], \"1700\" [:div [:p] [:div [:p/code {:code \"(dtype/make-container :jvm-heap :float16 5)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#array-buffer<float16>[5]\\n[]\\n\"}]], \"1802\" [:div [:p] nil nil [:p/markdown \"As for reducing along the first dimension: \\n\\n\\nAPL reference: \\n```APL\\n      draw +/[1] m\\n┏→━━━━━━━━━━━━━┓\\n↓15 18 21 24 27┃\\n┃60 63 66 69 72┃\\n┗━━━━━━━━━━━━━━┛\\n```\\n\\nOur version: \"]], \"1774\" [:div [:p] nil nil [:p/markdown \"### Absolute value\"]], \"1703\" [:div [:p] nil nil [:p/markdown \"Create a 3x5 floating-point array filled with 3.14\\n```python\\nnp.full((3, 5), 3.14)\\n```\"]], \"1773\" [:div [:p] [:div [:p/code {:code \"(->> (ns-publics 'tech.v3.datatype.functional)\\n     (map first)\\n     sort\\n     (take 100)\\n     (dtt/->tensor)\\n     (#(dtt/reshape % [25 4])))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[25 4]\\n[[                  *                     +                     -                      /]\\n [                  <                    <=                     >                     >=]\\n [                abs                  acos                   and                   asin]\\n [               atan                 atan2               bit-and            bit-and-not]\\n [          bit-clear              bit-flip               bit-not                 bit-or]\\n [            bit-set        bit-shift-left       bit-shift-right               bit-test]\\n [            bit-xor  bool-reader->indexes                  cbrt                   ceil]\\n [                cos                  cosh                cummax                 cummin]\\n [              cumop               cumprod                cumsum descriptive-statistics]\\n [           distance      distance-squared           dot-product                     eq]\\n [             equals                 even?                   exp                  expm1]\\n [         fill-range               finite?  fixed-rolling-window                  floor]\\n [    get-significand                 hypot              identity         ieee-remainder]\\n [          infinite?  kendalls-correlation              kurtosis                    log]\\n [              log10                 log1p              logistic              magnitude]\\n [  magnitude-squared mathematical-integer?                   max                   mean]\\n [             median                   min                  nan?                   neg?]\\n [          next-down               next-up                   not                 not-eq]\\n [               odd?                    or  pearsons-correlation            percentiles]\\n [               pos?                   pow            quartile-1             quartile-3]\\n [quartile-outlier-fn             quartiles                  quot               reduce-*]\\n [           reduce-+            reduce-max            reduce-min                    rem]\\n [               rint                 round                signum                    sin]\\n [               sinh                  skew spearmans-correlation                     sq]\\n [               sqrt    standard-deviation                   sum                    tan]]\\n\"}]], \"1798\" [:div [:p] [:div [:p/code {:code \"(nd-reduce 0 + m)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[3 5]\\n[[15 17 19 21 23]\\n [25 27 29 31 33]\\n [35 37 39 41 43]]\\n\"}]], \"1795\" [:div [:p] nil nil [:p/markdown \"APL reference:\\n\\n```apl \\n      draw +/[0] m\\n┏→━━━━━━━━━━━━━┓\\n↓15 17 19 21 23┃\\n┃25 27 29 31 33┃\\n┃35 37 39 41 43┃\\n┗━━━━━━━━━━━━━━┛\\n\\n```\\n\\nWhich is equivalent let: \"]], \"1737\" [:div [:p] [:div [:p/code {:code \"(array-slice x 19 0 -2)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[10]\\n[19 17 15 13 11 9 7 5 3 1]\\n\"}]], \"1701\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (constantly 0) nil\\n            (dtype/make-container :jvm-heap :int8 10))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[0 0 0 0 0 0 0 0 0 0]\\n\"}]], \"1731\" [:div [:p] nil nil [:p/markdown \"### Array Slicing: Accessing Subarrays\\n\\n`x[start:stop:step]`, e.g. `x[::2]  # every other element`, `x[5::-2]  # reversed every other from index 5`\"]], \"1697\" [:div [:p] nil nil [:p/markdown \"### Creating Arrays from ~Python~ Lists\\n\\nIn Python:\\n\\n```python\\n# integer array:\\nnp.array([1, 4, 2, 5, 3])\\n```\\n\\nIn Clojure we mostly don't work with low-level \\\"arrays\\\" but with \\\"datasets\\\".\\nIn 2D those consist of rows and (named) columns:\\n\"]], \"1719\" [:div [:p] [:div [:p/code {:code \"(eye 5)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[5 5]\\n[[1 0 0 0 0]\\n [0 1 0 0 0]\\n [0 0 1 0 0]\\n [0 0 0 1 0]\\n [0 0 0 0 1]]\\n\"}]], \"1766\" [:div [:p] nil nil [:p/markdown \"#### Introducing UFuncs\\n\\nEx.:\\n* `1.0 / matrice`\\n* `np.arange(5) / np.arange(1, 6)` - two arrays\\n* `x = np.arange(9).reshape((3, 3)); 2 ** x` - on multi-dimensional array\\n\\ndtype-next offers [`tech.v3.datatype.functional`](https://cnuernber.github.io/dtype-next/tech.v3.datatype.functional.html)\"]], \"1707\" [:div [:p] [:div [:p/code {:code \"(linspace 0 1 5)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[5]\\n[0 0.2500 0.5000 0.7500 1]\\n\"}]], \"1615\" [:div [:p] nil nil [:p/markdown \"#### Splitting of arrays\\n\\nThe opposite of concatenation is splitting, which is implemented by the functions `np.split`, `np.hsplit`, `np.vsplit`, and `np.dsplit` [depth?]. For each of these, we can pass a list of indices giving the split points:\"]], \"1704\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (constantly 3.14) nil\\n            (dtt/new-tensor [3 5]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[3 5]\\n[[3.140 3.140 3.140 3.140 3.140]\\n [3.140 3.140 3.140 3.140 3.140]\\n [3.140 3.140 3.140 3.140 3.140]]\\n\"}]], \"1821\" [:div [:p] [:div [:p/code {:code \"(mask zero? (eye 5))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[0 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 0]\\n\"}]], \"1771\" [:div [:p] nil nil [:p/markdown \"#### Array arithmetic\\n\\n* addition, subtraction, multiplication, and division (+ `floor_divide`).\\n* unary ufunc for negation, and a ** operator for exponentiation, and a % operator for modulus\\n\\nthese can be strung together however you wish, and the standard order of operations is respecte\"]], \"1740\" [:div [:p] [:div [:p/code {:code \"(defn select [t & coords]\\n  (let [shape-t (dtype/shape t)\\n        coords  (map-indexed (fn [i c]\\n                               (if (or (nil? c) (empty? c))\\n                                 (range (nth shape-t i))\\n                                 c))\\n                             coords)]\\n    (apply dtt/select t coords)))\", :bg-class \"bg-light\"}]] nil nil], \"1814\" [:div [:p] [:div [:p/code {:code \"(def csv-data (ds/->dataset \\\"https://raw.githubusercontent.com/jakevdp/PythonDataScienceHandbook/master/notebooks/data/president_heights.csv\\\"))\", :bg-class \"bg-light\"}]] nil nil], \"1772\" [:div [:p] nil nil [:p/markdown \"Check this table for all kinds of goodies available in `tech.v3.datatype.functional`\"]], \"1564\" [:div [:p] nil nil [:p/markdown \"Create a 3x3 identity matrix\\n```python\\nnp.eye(3)\\n```\"]], \"1611\" [:div [:p] [:div [:p/code {:code \"(def t235 (-> (dtt/->tensor (range (* 2 3 5)))\\n              (dtt/reshape [2 3 5])))\", :bg-class \"bg-light\"}]] nil nil], \"1816\" [:div [:p] [:div [:p/code {:code \"(tech.v3.datatype.functional/mean (dtype/->reader (-> csv-data last last)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"179.73809523809524\\n\"}]], \"1756\" [:div [:p] [:div [:p/code {:code \"(concatenate 0 t235 t235)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[4 3 5]\\n[[[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]\\n [[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]]\\n\"}]], \"1782\" [:div [:p] nil nil [:p/markdown \"#### Outer products\\n\\nFinally, any ufunc can compute the output of all pairs of two different inputs using the `outer` method. This allows you, in one line, to do things like create a multiplication table:\\n\\n```\\nx = np.arange(1, 6)\\nnp.multiply.outer(x, x)\\n```\"]], \"1732\" [:div [:p] [:div [:p/code {:code \"(def x (dtt/->tensor (range 20)))\", :bg-class \"bg-light\"}]] nil nil], \"1693\" [:div [:p] nil nil [:p/markdown \"### Fixed-Type Arrays in Python\\n\\nIn Clojure we use [dtype-next](https://github.com/cnuernber/dtype-next) (also known as\\n`tech.v3.datatype`) and the convenient wrapper with a consistent API, [tablecloth](https://scicloj.github.io/tablecloth/),\\nfor working efficiently with dataset data.\"]], \"1784\" [:div [:p] nil nil [:p/markdown \"### Ufuncs: Learning More\\n\\nMore information on universal functions (including the full list of available functions) can be found on the NumPy and SciPy documentation websites.\"]], \"1800\" [:div [:p] [:div [:p/code {:code \"(dtype/shape m)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[2 3 5]\\n\"}]], \"1826\" [:div [:p] [:div [:p/code {:code \"(let [words \\\"hello there\\\"]\\n  (compress\\n   (mask even? (dtt/->tensor (range (count words))))\\n   (dtt/->tensor (vec words))))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[6]\\n[h l o t e e]\\n\"}]], \"1744\" [:div [:p] nil nil [:p/markdown \"#### Creating copies of arrays\\n\\nDespite the nice features of array views, it is sometimes useful to instead explicitly copy the data within an array or a subarray.\"]], \"1804\" [:div [:p] nil nil [:p/markdown \"Again, the shape of `m` is [2 3 5]`.  The index 1 of the shape of `m` is `3`.  Therefore, \\nwhen we reduce along the 1 dimension of `m`, we can reason that the output shape will be \\n[2 5]. Observe:\"]], \"1736\" [:div [:p] [:div [:p/code {:code \"(array-slice x 0 20 2)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[10]\\n[0 2 4 6 8 10 12 14 16 18]\\n\"}]], \"1822\" [:div [:p] nil nil [:p/markdown \"Fancy Indexing\\n ------------------------------------------------\"]], \"1543\" [:div [:p] nil nil [:p/markdown \"### Creating Arrays from Scratch\\n\\nCreate an empty array of length 5:\"]], \"1708\" [:div [:p] nil nil [:p/markdown \"Create a 3x3 array of uniformly distributed random values between 0 and 1\\n```python\\nnp.random.random((3, 3))\\n```\"]], \"1546\" [:div [:p] nil nil [:p/markdown \"Create a length-10 integer array filled with zeros\\n```python\\nnp.zeros(10, dtype=int)\\n```\"]], \"1752\" [:div [:p] [:div [:p/code {:code \"(dtt/->tensor [(concat (dtype/->reader (select t23 [0] nil)) (dtype/->reader (select t22 [0] nil)))\\n               (concat (dtype/->reader (select t23 [1] nil)) (dtype/->reader (select t22 [1] nil)))])\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[2 5]\\n[[1 2 3 a b]\\n [4 5 6 c d]]\\n\"}]], \"1808\" [:div [:p] nil nil [:p/markdown \"Once more, the shape of `m` is [2 3 5].  Since the 2 dimension is 5, we can\\nreason that reducing the 2 dimension will result in an output shape of [2 3]: \"]], \"1810\" [:div [:p] nil nil [:p/markdown \"### Minimum and Maximum\\n\\n`np.min(big_array), np.max(big_array)`\"]], \"1820\" [:div [:p] [:div [:p/code {:code \"(defn mask [f t]\\n  (-> (dtype/emap #(if (f %) 1 0) :int32 t)\\n      dtt/->tensor\\n      ravel))\", :bg-class \"bg-light\"}]] nil nil], \"1715\" [:div [:p] [:div [:p/code {:code \"(defn index [args]\\n  (if-let [f (and (< (count args) 15)\\n                  (case (count args)\\n                    0 nil\\n                    1 (fn [a] [a])\\n                    2 (fn [a b] [a b])\\n                    3 (fn [a b c]\\n                        [a b c])\\n                    4 (fn [a b c d]\\n                        [a b c d])\\n                    5 (fn [a b c d e]\\n                        [a b c d e])\\n                    6 (fn [a b c d e f]\\n                        [a b c d e f])\\n                    7 (fn [a b c d e f g]\\n                        [a b c d e f g])\\n                    8 (fn [a b c d e f g h]\\n                        [a b c d e f g h])\\n                    9 (fn [a b c d e f g h i]\\n                        [a b c d e f g h i])\\n                    10 (fn [a b c d e f g h i j]\\n                         [a b c d e f g h i j])\\n                    11 (fn [a b c d e f g h i j k]\\n                         [a b c d e f g h i j k])\\n                    12 (fn [a b c d e f g h i j k l]\\n                         [a b c d e f g h i j k l])\\n                    13 (fn [a b c d e f g h i j k l m]\\n                         [a b c d e f g h i j k l m])\\n                    14 (fn [a b c d e f g h i j k l m n]\\n                         [a b c d e f g h i j k l m n])\\n                    15 (fn [a b c d e f g h i j k l m n o]\\n                         [a b c d e f g h i j k l m n o])))]\\n    (-> (dtt/compute-tensor (vec args) f)\\n        dtype/->reader))\\n  (slow-index (vec args)))\", :bg-class \"bg-light\"}]] nil nil], \"1779\" [:div [:p] nil nil [:p/markdown \"### Advanced Ufunc Features\"]], \"1714\" [:div [:p] nil nil [:p/markdown \"We currently do not have a good approximation of this technique.  However,\\nit is easy enough to compute an identity matrix using an outer product operation.\"]], \"1730\" [:div [:p] [:div [:p/code {:code \"(nth f32 1)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"4.0\\n\"}]], \"1805\" [:div [:p] [:div [:p/code {:code \"(dtype/shape (nd-reduce 1 + m))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[2 5]\\n\"}]], \"1777\" [:div [:p] nil nil [:p/markdown \"#### Specialized ufuncs\\n\\nNumPy has many more ufuncs available, including hyperbolic trig functions, bitwise arithmetic, comparison operators, conversions from radians to degrees, rounding and remainders, and much more. A look through the NumPy documentation reveals a lot of interesting functionality.\\n\\nAnother excellent source for more specialized and obscure ufuncs is the submodule scipy.special. If you want to compute some obscure mathematical function on your data, chances are it is implemented in scipy.special. There are far too many functions to list them all...\"]], \"1540\" [:div [:p] nil nil [:p/markdown \"Containers are space- and time-efficient data structures with fast copy, including from/to native memory (for sharing with external processes).\\n\\nA container is backed by a raw, typed _buffer_. A read-only view of a buffer is called _reader_.\\n\\nFor multi-dimensional data, dtype-next offers *tensors*:\\n\\n> Generic N-dimensional support built on top of buffers and dimension objects. Conceptually you combine a raw data buffer with an indexing mechanism capable if transforming multiple dimension address into a linear address into the raw data buffer.\\n\\n(We will see more of tensors later.)\"]], \"1811\" [:div [:p] nil nil [:p/markdown \"#### Multi dimensional aggregates\\n\\nOne common type of aggregation operation is an aggregate along a row or column. Say you have some data stored in a two-dimensional array.\\n\\nAggregation functions take an additional argument specifying the axis along which the aggregate is computed. For example, we can find the minimum value within each column by specifying `axis=0`:\\n\\n```\\nM.min(axis=0)\\n=> array([ 0.66859307,  0.03783739,  0.19544769,  0.06682827])\\n```\"]], \"1554\" [:div [:p] nil nil [:p/markdown \"Create an array of five values evenly spaced between 0 and 1 ❓\\n```python\\nnp.linspace(0, 1, 5)\\n\"]], \"1787\" [:div [:p] nil nil [:p/markdown \"(Note: Investigate kixi stats and fastmath for this purpose)\"]], \"1778\" [:div [:p] nil nil [:p/markdown \"`dtype/emap` will serve the vast majority of those needs\"]], \"1761\" [:div [:p] [:div [:p/code {:code \"(defn split\\n  ([t pieces] (split 0 t pieces))\\n  ([axis t pieces]\\n   (into []\\n         (comp \\n          (map (fn [x] (range (first x) (second x))))\\n          (map #(conj (mapv (constantly nil) (range axis)) %))\\n          (map #(apply select t %)))\\n         (->> (dtype/emap #(-> %\\n                               Math/floor\\n                               int)\\n                          :object\\n                          (if-let [v (and  (vector? pieces)\\n                                           (-> (normalize (dtt/reshape (dtt/->tensor pieces)\\n                                                                       [1 (count pieces)]))\\n                                               (dtt/reshape [(count pieces)])))]\\n                            ;; individual element selection\\n                            (tech.v3.datatype.functional/* v\\n                                                           (nth (dtype/shape t) axis))\\n                            ;; number of partitions selection\\n                            (tech.v3.datatype.functional/* (linspace 0 1 (inc pieces))\\n                                                           (nth (dtype/shape t) axis))))\\n              (partition 2 1)))))\", :bg-class \"bg-light\"}]] nil nil], \"1758\" [:div [:p] [:div [:p/code {:code \"(concatenate 2 t235 t235)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[2 3 10]\\n[[[ 0  1  2  3  4  0  1  2  3  4]\\n  [ 5  6  7  8  9  5  6  7  8  9]\\n  [10 11 12 13 14 10 11 12 13 14]]\\n [[15 16 17 18 19 15 16 17 18 19]\\n  [20 21 22 23 24 20 21 22 23 24]\\n  [25 26 27 28 29 25 26 27 28 29]]]\\n\"}]], \"1827\" [:div [:p] nil nil [:p/markdown \"Sorting Arrays\\n ------------------------------------------------\"]], \"1747\" [:div [:p] nil nil [:p/markdown \"### Array Concatenation and Splitting\\n\\nAll of the preceding routines worked on single arrays. It's also possible to combine multiple arrays into one, and to conversely split a single array into multiple arrays. \"]], \"1728\" [:div [:p] nil nil [:p/markdown \"Accessing nth element of a container, e.g. for n=2:\"]], \"1797\" [:div [:p] nil nil [:p/markdown \"Which is equivalent to: \"]], \"1705\" [:div [:p] nil nil [:p/markdown \"Create an array filled with a linear sequence\\nStarting at 0, ending at 20, stepping by 2\\n```python\\nnp.arange(0, 20, 2)\\n```\"]], \"1823\" [:div [:p] [:div [:p/code {:code \"(defn compress\\n  \\\"Use compress to do an elementwise selection according to an interger boolean\\nmask. lhs and rhs must have the same element count.  A 0 on the lhs will drop the corresponding\\nelement on the rhs.  A 1 on the rhs will keep the element. 2 or great will cause replication\\nof the element on the rhs. Returns a tensor of rank 1.\\\"\\n  [lhs rhs]\\n  (let [rhs   (dtt/->tensor rhs)\\n        rhr   (dtt/->tensor (ravel rhs))\\n        dt    (dtype/get-datatype rhs)\\n        shape (dtype/shape lhs)\\n        idx'  (into []\\n                    (comp\\n                     (partition-all 2)\\n                     (map #(repeat (first %) (second %)))\\n                     cat)\\n                    (interleave lhs (index shape)))\\n        size  (count idx')]\\n    (-> (dtype/make-reader :object size (apply dtt/mget rhr (nth idx' idx)))\\n        (dtt/->tensor))))\", :bg-class \"bg-light\"}]] nil nil], \"1818\" [:div [:p] nil nil [:p/markdown \"Computation on Arrays: Broadcasting\\n ------------------------------------------------\"]], \"1727\" [:div [:p] nil nil [:p/markdown \"### Array Indexing: Accessing Single Elements\\n\\nEx.: `x[4]`, `x[-1]`, `x[1,2]`\"]], \"1794\" [:div [:p] [:div [:p/code {:code \"m\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[2 3 5]\\n[[[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]]\\n\"}]], \"1792\" [:div [:p] nil nil [:p/markdown \"APL reference:\\n\\n```apl\\n      draw m\\n┏→━━━━━━━━━━━━━┓\\n↓ 0  1  2  3  4┃\\n┃ 5  6  7  8  9┃\\n┃10 11 12 13 14┃\\n┃              ┃\\n┃15 16 17 18 19┃\\n┃20 21 22 23 24┃\\n┃25 26 27 28 29┃\\n┗━━━━━━━━━━━━━━┛\\n \\n```\\n\\nOur version:\"]], \"1542\" [:div [:p] [:div [:p/code {:code \"(api/dataset {:v [3.14, 4, 2, 3]} {:dataset-name \\\"Mixed int and float\\\"})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"Mixed int and float [4 1]:\\n\\n|   :v |\\n|-----:|\\n| 3.14 |\\n| 4.00 |\\n| 2.00 |\\n| 3.00 |\\n\\n\"}]], \"1767\" [:div [:p] [:div [:p/code {:code \"(tech.v3.datatype.functional// 1.0 t)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[2 3 5]\\n[[[INFINITY   1.000  0.5000  0.3333  0.2500]\\n  [  0.2000  0.1667  0.1429  0.1250  0.1111]\\n  [  0.1000 0.09091 0.08333 0.07692 0.07143]]\\n [[ 0.06667 0.06250 0.05882 0.05556 0.05263]\\n  [ 0.05000 0.04762 0.04545 0.04348 0.04167]\\n  [ 0.04000 0.03846 0.03704 0.03571 0.03448]]]\\n\"}]], \"1745\" [:div [:p] nil nil [:p/markdown \"### Reshaping of Arrays\\n\\nFor example, if you want to put the numbers 1 through 9 in a 3×3 grid\"]], \"1695\" [:div [:p] nil nil nil], \"1562\" [:div [:p] nil nil [:p/markdown \"Create a 3x3 array of random integers in the interval [0, 10]\\n```python\\nnp.random.randint(0, 10, (3, 3))\\n```\"]], \"1775\" [:div [:p] nil nil [:p/markdown \"### Trigonometric functions\\n\\n```\\ntheta = np.linspace(0, np.pi, 3)\\nprint(\\\"theta      = \\\", theta)\\nprint(\\\"sin(theta) = \\\", np.sin(theta))\\nprint(\\\"cos(theta) = \\\", np.cos(theta))\\nprint(\\\"tan(theta) = \\\", np.tan(theta))\\nnp.arcsin(x)\\nnp.arccos(x)\\nnp.arctan(x)\\n```\"]], \"1781\" [:div [:p] nil nil [:p/markdown \"#### Aggregates\\n\\nFor binary ufuncs, there are some interesting aggregates that can be computed directly from the object. For example, if we'd like to reduce an array with a particular operation, we can use the reduce method of any ufunc. A reduce repeatedly applies a given operation to the elements of an array until only a single result remains.\\n\\nFor example, calling reduce on the add ufunc returns the sum of all elements in the array:\\n\\n```\\nx = np.arange(1, 6)\\nnp.add.reduce(x)      # 15\\nnp.multiply.reduce(x) # 120\\nnp.add.accumulate(x)  # [1, 3, ..] - store all the intermediate results of reduce\\n\\n```\"]], \"1799\" [:div [:p] nil nil [:p/markdown \"Note that the initial shape of `m` is `[2 3 5]` and that `(first  m)` is 2.\\nTherefore when you reduce along axis 0, you can reason that the output shape will\\nbe [3 5].\"]], \"1791\" [:div [:p] nil nil [:p/markdown \"Example of reducing along the 0th dimension\"]], \"1760\" [:div [:p] [:div [:p/code {:code \"(normalize t)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[2 3]\\n[[0 0 0]\\n [0 0 1]]\\n\"}]], \"1789\" [:div [:p] [:div [:p/code {:code \"(defn nd-aggregate\\n  \\\"Reduce along an axis with an element-wise reduction.\\n   The entire dimension is presented to the\\nreducing function for an aggregation (such as `mean`).\\\"\\n  ([f t]\\n   (nd-aggregate 0 f t))\\n  ([axis f t]\\n   (nd-aggregate 0 f t (dtype/elemwise-datatype t)))\\n  ([axis f t datatype]\\n   (if (= 1 (scalar-rank t)) ;; TEMPORARY until dtt/reduce-axis handles 1D\\n     (f t)\\n     (dtt/reduce-axis f t axis datatype))))\", :bg-class \"bg-light\"}]] nil nil], \"1790\" [:div [:p] [:div [:p/code {:code \"(defn nd-reduce\\n  \\\"Reduce along an axis with an element-wise reduction.\\\"\\n  ([f t]\\n   (nd-reduce 0 f t))\\n  ([axis f t]\\n   (nd-reduce axis f t (dtype/elemwise-datatype t)))\\n  ([axis f t datatype]\\n   (nd-aggregate axis (partial apply f) t datatype)))\", :bg-class \"bg-light\"}]] nil nil], \"1739\" [:div [:p] nil nil [:p/markdown \"#### Accessing array rows and columns\\n\\nOne commonly needed routine is accessing of single rows or columns of an array.\\n\\n`print(x2[:, 0])  # first column of x2`\\n`print(x2[0, :])  # first row of x2`\"]], \"1691\" [:div [:p] nil nil [:p/markdown \"\\n[Python Data Science - ch.2. NumPy translated to Clojure](https://jakevdp.github.io/PythonDataScienceHandbook/02.06-boolean-arrays-and-masks.html)\\n=======================================================\\n\\n\"]], \"1604\" [:div [:p] [:div [:p/code {:code \"(defn concatenate\\n  ([a b] (concatenate (dec (scalar-rank a)) a b))\\n  ([axis a b]\\n   (let [left-shape        (dtype/shape a)\\n         right-shape       (dtype/shape b)\\n         left-join-rank    (nth (dtype/shape a) axis)\\n         right-join-rank   (nth (dtype/shape b) axis)\\n         left-cross-shape  (map-indexed (fn [i c] (if (= i axis) nil (range c)))\\n                                        (dtype/shape a))\\n         right-cross-shape (map-indexed (fn [i c] (if (= i axis) nil (range c)))\\n                                        (dtype/shape b))\\n         left-cross        (filter some? left-cross-shape)\\n         right-cross       (filter some? right-cross-shape)\\n         crosses           (map dtt/->tensor (interleave left-cross right-cross))\\n         final-shape       (map-indexed\\n                            (fn [i d]\\n                              (if (= i axis) (+ left-join-rank right-join-rank) d))\\n                            left-shape)\\n         idx'              (dtype/emap\\n                            (fn [idx]\\n                              (let [special-rank  (nth idx axis)\\n                                    target-tensor (if (< special-rank left-join-rank) a b)\\n                                    special-idx   (if (< special-rank left-join-rank)\\n                                                    special-rank\\n                                                    (- special-rank left-join-rank))\\n                                    target-coords\\n                                    (map-indexed (fn [i d] (if (= i axis) special-idx d)) idx)]\\n                                (apply dtt/mget target-tensor target-coords)))\\n                            :object\\n                            (dtype/->reader (vec (index final-shape))))]\\n     (dtt/reshape idx' final-shape))))\", :bg-class \"bg-light\"}]] nil nil], \"1751\" [:div [:p] [:div [:p/code {:code \"(def t22 (dtt/->tensor [[\\\"a\\\" \\\"b\\\"] [\\\"c\\\" \\\"d\\\"]]))\", :bg-class \"bg-light\"}]] nil nil], \"1566\" [:div [:p] [:div [:p/code {:code \"(defn ^:private slow-index\\n  \\\"Like range, but for tensors.  Enumerates the indicies.\\\"\\n  [shape]\\n  (let [space  (apply * shape)\\n        rshape (reverse shape)\\n        muls   (cons 1 (pop (vec (reductions * rshape))))]\\n    (-> (mapv\\n         (fn [idx]\\n           (vec \\n            (reverse\\n             (map (fn [p n]\\n                    (-> idx\\n                        (quot n)\\n                        (mod p)))\\n                  rshape\\n                  muls))))\\n         (range space))\\n        dtype/->reader)))\", :bg-class \"bg-light\"}]] nil nil], \"1764\" [:div [:p] [:div [:p/code {:code \"(let [t (->> (concatenate 0 t t)\\n             (concatenate 0 t))]\\n  (split 2 t [2 3 4 2]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[#tech.v3.tensor<object>[6 3 2]\\n[[[ 0  1]\\n  [ 5  6]\\n  [10 11]]\\n [[15 16]\\n  [20 21]\\n  [25 26]]\\n [[ 0  1]\\n  [ 5  6]\\n  [10 11]]\\n [[15 16]\\n  [20 21]\\n  [25 26]]\\n [[ 0  1]\\n  [ 5  6]\\n  [10 11]]\\n [[15 16]\\n  [20 21]\\n  [25 26]]] #tech.v3.tensor<object>[6 3 3]\\n[[[ 2  3  4]\\n  [ 7  8  9]\\n  [12 13 14]]\\n [[17 18 19]\\n  [22 23 24]\\n  [27 28 29]]\\n [[ 2  3  4]\\n  [ 7  8  9]\\n  [12 13 14]]\\n [[17 18 19]\\n  [22 23 24]\\n  [27 28 29]]\\n [[ 2  3  4]\\n  [ 7  8  9]\\n  [12 13 14]]\\n [[17 18 19]\\n  [22 23 24]\\n  [27 28 29]]] #tech.v3.tensor<object>[6 3 5]\\n[[[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]\\n [[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]\\n [[ 0  1  2  3  4]\\n  [ 5  6  7  8  9]\\n  [10 11 12 13 14]]\\n [[15 16 17 18 19]\\n  [20 21 22 23 24]\\n  [25 26 27 28 29]]]]\\n\"}]], \"1750\" [:div [:p] [:div [:p/code {:code \"(def t23 (dtt/->tensor [[1 2 3] [4 5 6]]))\", :bg-class \"bg-light\"}]] nil nil], \"1770\" [:div [:p] nil nil [:p/markdown \"### Exploring NumPy's UFuncs\"]], \"1548\" [:div [:p] nil nil [:p/markdown \"Create a 3x5 floating-point array filled with ones\\n```python\\nnp.ones((3, 5), dtype=float)\\n```\"]], \"1806\" [:div [:p] nil nil [:p/markdown \"And finally for reducing along the last dimension:\\n\\nAPL reference:\\n\\n```apl\\n      draw +/[2] m\\n┏→━━━━━━━━━┓\\n↓10  35  60┃\\n┃85 110 135┃\\n┗━━━━━━━━━━┛\\n```\\n\\n\"]], \"1793\" [:div [:p] [:div [:p/code {:code \"(def m t)\", :bg-class \"bg-light\"}]] nil nil], \"1765\" [:div [:p] nil nil [:p/markdown \"Computation on NumPy Arrays: Universal Functions\\n ------------------------------------------------\\n\\n Computation on NumPy arrays can be very fast, or it can be very slow. The key to making it fast is to use vectorized operations, generally implemented through NumPy's universal functions (ufuncs). This section motivates the need for NumPy's ufuncs, which can be used to make repeated calculations on array elements much more efficient. It then introduces many of the most common and useful arithmetic ufuncs available in the NumPy package.\"]], \"1722\" [:div [:p] nil nil [:p/markdown \"### NumPy Standard Data Types\\n\\n```\\nData type \\tDescription\\nbool_ \\tBoolean (True or False) stored as a byte\\nint_ \\tDefault integer type (same as C long; normally either int64 or int32)\\nintc \\tIdentical to C int (normally int32 or int64)\\nintp \\tInteger used for indexing (same as C ssize_t; normally either int32 or int64)\\nint8 \\tByte (-128 to 127)\\nint16 \\tInteger (-32768 to 32767)\\nint32 \\tInteger (-2147483648 to 2147483647)\\nint64 \\tInteger (-9223372036854775808 to 9223372036854775807)\\nuint8 \\tUnsigned integer (0 to 255)\\nuint16 \\tUnsigned integer (0 to 65535)\\nuint32 \\tUnsigned integer (0 to 4294967295)\\nuint64 \\tUnsigned integer (0 to 18446744073709551615)\\nfloat_ \\tShorthand for float64.\\nfloat16 \\tHalf precision float: sign bit, 5 bits exponent, 10 bits mantissa\\nfloat32 \\tSingle precision float: sign bit, 8 bits exponent, 23 bits mantissa\\nfloat64 \\tDouble precision float: sign bit, 11 bits exponent, 52 bits mantissa\\ncomplex_ \\tShorthand for complex128.\\ncomplex64 \\tComplex number, represented by two 32-bit floats\\ncomplex128 \\tComplex number, represented by two 64-bit floats\\n```\\n\\ndtype-next data types:\\n\\n```\\n:boolean\\n:char\\n:int8\\n:int16\\n:int32\\n:int64\\n:uint8\\n:uint16\\n:uint32\\n:uint64\\n:float32\\n:float64\\n```\"]], \"1733\" [:div [:p] [:div [:p/code {:code \"(declare select)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#'scicloj.02-numpy/select\\n\"}]], \"1711\" [:div [:p] nil nil [:p/markdown \"Create a 3x3 array of normally distributed random values with mean 0 and standard deviation 1\\n```python\\nnp.random.normal(0, 1, (3, 3))\\n```\"]], \"1718\" [:div [:p] [:div [:p/code {:code \"(eye 3)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[3 3]\\n[[1 0 0]\\n [0 1 0]\\n [0 0 1]]\\n\"}]], \"1726\" [:div [:p] [:div [:p/code {:code \"(dtype/get-datatype f32)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \":float32\\n\"}]], \"1809\" [:div [:p] [:div [:p/code {:code \"(dtype/shape (nd-reduce 2 + m))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[2 3]\\n\"}]], \"1692\" [:div [:p] nil nil [:p/markdown \"Understanding Data Types in Python\\n ------------------------------------------------\"]], \"1698\" [:div [:p] nil nil [:p/markdown \"Datasets are provided by `tech.v3.dataset` and made convenient via Tablecloth.\\n\\nThe underlying data structure - from `tech.v3.datatype` - is a \\\"container\\\", very similar to numpy arrays. From the [dtype Cheatshet](https://cnuernber.github.io/dtype-next/cheatsheet.html):\\n\\n> There are two different types of containers in tech.v3.datatype; jvm-heap containers and native-heap containers. Object datatypes are only supported in jvm-heap containers and native-heap containers have mmap support and offer zero-copy pathways to toolkits like Python’s numpy and Clojure’s neanderthal.\"]], \"1538\" [:div [:p] [:div [:p/code {:code \"(api/dataset {:column1 [1 4 2 5 3]})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [5 1]:\\n\\n| :column1 |\\n|---------:|\\n|        1 |\\n|        4 |\\n|        2 |\\n|        5 |\\n|        3 |\\n\\n\"}]], \"1716\" [:div [:p] [:div [:p/code {:code \"(index [3 3])\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]]\\n\"}]], \"1769\" [:div [:p] [:div [:p/code {:code \"(-> (range 9)\\n    (dtt/->tensor)\\n    (dtt/reshape [3 3])\\n    (->> (dtype/emap #(Math/pow % 2) nil)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[3 3]\\n[[ 0  1  4]\\n [ 9 16 25]\\n [36 49 64]]\\n\"}]], \"1555\" [:div [:p] [:div [:p/code {:code \"(defn ^{:doc \\\"Temporary workaround, maybe there is a better way to do this\\\"}\\n  linspace\\n  ([start stop] (linspace start stop 50))\\n  ([start stop n]\\n   (let [delta (- stop start)\\n         end   (dec n)]\\n     (dtt/->tensor (map (fn [i] (/ (* i delta) end))\\n                        (range n))))))\", :bg-class \"bg-light\"}]] nil nil], \"1812\" [:div [:p] nil nil [:p/markdown \"#### Other aggregation functions\\n\\nNumPy provides many other aggregation functions, but we won't discuss them in detail here. Additionally, most aggregates have a NaN-safe counterpart that computes the result while ignoring missing values, which are marked by the special IEEE floating-point NaN value (for a fuller discussion of missing data, see Handling Missing Data).\\n\\nThe following table provides a list of useful aggregation functions available in NumPy:\\n\\n```\\nFunction Name \\tNaN-safe Version \\tDescription\\nnp.sum \\tnp.nansum \\tCompute sum of elements\\nnp.prod \\tnp.nanprod \\tCompute product of elements\\nnp.mean \\tnp.nanmean \\tCompute mean of elements\\nnp.std \\tnp.nanstd \\tCompute standard deviation\\nnp.var \\tnp.nanvar \\tCompute variance\\nnp.min \\tnp.nanmin \\tFind minimum value\\nnp.max \\tnp.nanmax \\tFind maximum value\\nnp.argmin \\tnp.nanargmin \\tFind index of minimum value\\nnp.argmax \\tnp.nanargmax \\tFind index of maximum value\\nnp.median \\tnp.nanmedian \\tCompute median of elements\\nnp.percentile \\tnp.nanpercentile \\tCompute rank-based statistics of elements\\nnp.any \\tN/A \\tEvaluate whether any elements are true\\nnp.all \\tN/A \\tEvaluate whether all elements are true\\n```\\n\"]], \"1786\" [:div [:p] nil nil [:p/markdown \"### Clojure: descriptive stats\\n\\n`ds/descriptive-stats` displays these stats: `n-valid`, `n-missing`, `min`, `mean`, `mode`, `max`, `standard-deviation`, `skew`\"]], \"1735\" [:div [:p] nil nil [:p/markdown \"These work as expected\"]], \"1545\" [:div [:p] nil nil [:p/markdown \"Numpy has a number of ways of initializing new arrays with values:\"]], \"1801\" [:div [:p] [:div [:p/code {:code \"(dtype/shape (nd-reduce 0 + m))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[3 5]\\n\"}]], \"1696\" [:div [:p] nil nil nil], \"1755\" [:div [:p] [:div [:p/code {:code \"(-> (concatenate 0 t23 t23)\\n    (concatenate (concatenate 0 t22 t22)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[4 5]\\n[[1 2 3 a b]\\n [4 5 6 c d]\\n [1 2 3 a b]\\n [4 5 6 c d]]\\n\"}]], \"1721\" [:div [:p] [:div [:p/code {:code \"(dtype/make-container :jvm-heap :float32 3)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#array-buffer<float32>[3]\\n[0.000, 0.000, 0.000]\\n\"}]], \"1723\" [:div [:p] nil nil [:p/markdown \"The Basics of NumPy Arrays\\n ------------------------------------------------\"]], \"1754\" [:div [:p] [:div [:p/code {:code \"(concatenate t23 t22)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[2 5]\\n[[1 2 3 a b]\\n [4 5 6 c d]]\\n\"}]], \"1594\" [:div [:p] [:div [:p/code {:code \"(def t (-> (dtt/->tensor (range (* 2 3)))\\n           (dtt/reshape [2 3])))\", :bg-class \"bg-light\"}]] nil nil], \"1768\" [:div [:p] [:div [:p/code {:code \"(tech.v3.datatype.functional// (dtt/->tensor (map float (range 5)))\\n                               (dtt/->tensor (map float (range 1 6))))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[0.0 0.5 0.6666666666666666 0.75 0.8]\\n\"}]], \"1713\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (fn [_] (fm.rand/irand 0 11)) nil\\n            (dtt/new-tensor [3 3]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[3 3]\\n[[6.000 6.000 8.000]\\n [5.000 10.00 1.000]\\n [4.000 7.000 4.000]]\\n\"}]], \"1702\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (constantly 1) nil\\n            (dtt/new-tensor [3 5]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[3 5]\\n[[1.000 1.000 1.000 1.000 1.000]\\n [1.000 1.000 1.000 1.000 1.000]\\n [1.000 1.000 1.000 1.000 1.000]]\\n\"}]], \"1762\" [:div [:p] [:div [:p/code {:code \"(def t (-> (dtt/->tensor (range (* 2 3 5)))\\n           (dtt/reshape [2 3 5])))\", :bg-class \"bg-light\"}]] nil nil], \"1694\" [:div [:p] [:div [:p/code {:code \"(require\\n '[tech.v3.dataset :as ds]\\n '[tech.v3.datatype :as dtype]\\n '[tech.v3.tensor :as dtt]\\n '[tablecloth.api :as api])\", :bg-class \"bg-light\"}]] nil nil], \"1729\" [:div [:p] [:div [:p/code {:code \"(f32 1)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"4.0\\n\"}]], \"1724\" [:div [:p] nil nil [:p/markdown \"### NumPy Array Attributes\\n\\n`ndim, size, shape` (list of dimension lengths), `dtype` e.g. int64,\\n`itemsize` in bytes and the total `nbytes` count.\"]], \"1746\" [:div [:p] [:div [:p/code {:code \"(-> (dtt/->tensor (range 1 10))\\n    (dtt/reshape [3 3]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[3 3]\\n[[1 2 3]\\n [4 5 6]\\n [7 8 9]]\\n\"}]], \"1817\" [:div [:p] [:div [:p/code {:code \"(letfn [(mean [x] (float (/ (apply + x) (count x))))]\\n  (nd-aggregate mean\\n                (dtype/->reader (-> csv-data last last))))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"179.7381\\n\"}]], \"1788\" [:div [:p] nil nil [:p/markdown \"### Summing the Values in an Array\\n`np.sum(L)`\"]], \"1743\" [:div [:p] nil nil [:p/markdown \"#### Subarrays as no-copy views\\n\\nviews rather than copies of the array data\\n\\nNOTE: You can use `tech.v3.datatype.argops` to create \\\"indexes\\\" for a buffer and then\\ncombine these with the buffer using `tech.v3.datatype/indexed-buffer` to create a custom\\nview of the original buffer\"]], \"1741\" [:div [:p] [:div [:p/code {:code \"(select t nil [0])\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[2 1]\\n[0 3]\\n\"}]], \"1530\" [:div [:p] nil nil nil], \"1749\" [:div [:p] [:div [:p/code {:code \"(defn scalar-rank [t] (-> t dtype/shape dtype/shape first))\", :bg-class \"bg-light\"}]] nil nil], \"1699\" [:div [:p] nil nil [:p/markdown \"A dataset column is constrained to a single value type. If types do not match, they will be upcasted if possible (here, integers are up-cast to floating point):\"]], \"1734\" [:div [:p] [:div [:p/code {:code \"(defn array-slice\\n  ([t stop]\\n   (dtt/select t (range stop)))\\n  ([t start stop]\\n   (dtt/select t (range start stop)))\\n  ([t start stop step]\\n   (dtt/select t (range start stop step))))\", :bg-class \"bg-light\"}]] nil nil], \"1759\" [:div [:p] [:div [:p/code {:code \"(defn normalize [t]\\n  (let [min (tech.v3.datatype.functional/min t (apply min (ravel t)))\\n        max (tech.v3.datatype.functional/max t (apply max (ravel t)))\\n        n   (first (dtype/shape t))]\\n    (tech.v3.datatype.functional//\\n     (tech.v3.datatype.functional/- t min)\\n     (tech.v3.datatype.functional/- max min))))\", :bg-class \"bg-light\"}]] nil nil], \"1742\" [:div [:p] [:div [:p/code {:code \"(select t [0] nil)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<int64>[1 3]\\n[0 1 2]\\n\"}]], \"1780\" [:div [:p] nil nil [:p/markdown \"#### Specifying output\\n\\nFor large calculations, it is sometimes useful to be able to specify the array where the result of the calculation will be stored. Rather than creating a temporary array, this can be used to write computation results directly to the memory location where you'd like them to be. For all ufuncs, this can be done using the out argument of the function\"]], \"1828\" [:div [:p] nil nil [:p/markdown \"Structured Data: NumPy's Structured Arrays\\n  ------------------------------------------------\"]], \"1738\" [:div [:p] nil nil [:p/markdown \"### Multi-dimensional subarrays\\n\\nSame as for 1D arrays.\\n\\n`x2[:2, :3]  # two rows, three columns`\\n\\nClj: You can get/set subrects at a given time using mget/mset! pathways from `tech.v3.tensor`.\"]], \"1824\" [:div [:p] [:div [:p/code {:code \"(compress [0 0 1 0 2] [1 1 2 3 4])\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[3]\\n[2 4 4]\\n\"}]], \"1763\" [:div [:p] [:div [:p/code {:code \"(let [t (->> (concatenate 0 t t)\\n             (concatenate 0 t))]\\n  (split 2 t 5))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"[#tech.v3.tensor<object>[6 3 1]\\n[[ 0  5 10]\\n [15 20 25]\\n [ 0  5 10]\\n [15 20 25]\\n [ 0  5 10]\\n [15 20 25]] #tech.v3.tensor<object>[6 3 1]\\n[[ 1  6 11]\\n [16 21 26]\\n [ 1  6 11]\\n [16 21 26]\\n [ 1  6 11]\\n [16 21 26]] #tech.v3.tensor<object>[6 3 1]\\n[[ 2  7 12]\\n [17 22 27]\\n [ 2  7 12]\\n [17 22 27]\\n [ 2  7 12]\\n [17 22 27]] #tech.v3.tensor<object>[6 3 1]\\n[[ 3  8 13]\\n [18 23 28]\\n [ 3  8 13]\\n [18 23 28]\\n [ 3  8 13]\\n [18 23 28]] #tech.v3.tensor<object>[6 3 1]\\n[[ 4  9 14]\\n [19 24 29]\\n [ 4  9 14]\\n [19 24 29]\\n [ 4  9 14]\\n [19 24 29]]]\\n\"}]], \"1706\" [:div [:p] [:div [:p/code {:code \"(dtype/make-container :jvm-heap :int8 (range 0 20 2))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#array-buffer<int8>[10]\\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\\n\"}]], \"1785\" [:div [:p] nil nil [:p/markdown \"Aggregations: Min, Max, and Everything In Between\\n ------------------------------------------------\\n\\n Often when faced with a large amount of data, a first step is to compute summary statistics for the data in question. Perhaps the most common summary statistics are the mean and standard deviation, which allow you to summarize the \\\"typical\\\" values in a dataset, but other aggregates are useful as well (the sum, product, median, minimum and maximum, quantiles, etc.).\\n\\n NumPy has fast built-in aggregation functions for working on arrays; we'll discuss and demonstrate some of them here.\"]], \"1710\" [:div [:p] [:div [:p/code {:code \"(dtype/emap (fn [_] (fm.rand/frand)) nil\\n            (dtt/new-tensor [3 3]))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<float64>[3 3]\\n[[0.2662 0.3193 0.3796]\\n [0.1212 0.8868 0.9453]\\n [0.2967 0.6194 0.6673]]\\n\"}]], \"1725\" [:div [:p] [:div [:p/code {:code \"(count f32)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"5\\n\"}]], \"1748\" [:div [:p] nil nil [:p/markdown \"#### Concatenation of arrays\\n\\nNumPy: `np.concatenate, np.vstack, and np.hstack`\"]], \"1783\" [:div [:p] [:div [:p/code {:code \"(let [x (dtt/->tensor (range 1 6))]\\n  (outer-product * x x))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.tensor<object>[5 5]\\n[[1  2  3  4  5]\\n [2  4  6  8 10]\\n [3  6  9 12 15]\\n [4  8 12 16 20]\\n [5 10 15 20 25]]\\n\"}]], \"1709\" [:div [:p] [:div [:p/code {:code \"(require '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}]] nil nil], \"1720\" [:div [:p] nil nil [:p/markdown \"Create an uninitialized array of three integers. The values will be whatever happens to already exist at that memory location\\n```python\\nnp.empty(3)\\n```\"]]}}"</script>
    <script src="gorilla-notes/js/compiled/main.js"></script>
</html>
