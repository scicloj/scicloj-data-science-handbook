<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script src="https://cdn.jsdelivr.net/gh/scicloj/gorilla-notes@master/dist/0.5.0-SNAPSHOT-5/main.js"></script>
    <script>
     shadow.loader.load("main");
     gorilla_notes.main.main_BANG_(false, "{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Tue Dec 15 13:16:40 CST 2020\"] nil nil [:hr]], :custom-footer [:div [:hr]]}, :ids [\"198\" \"199\" \"200\" \"201\" \"187\" \"188\" \"154\" \"202\" \"203\" \"204\" \"175\" \"176\" \"191\" \"205\" \"206\" \"193\" \"194\" \"207\" \"208\"], :id->content {\"191\" [:div nil [:div [:p/markdown \"For binary operations on two Series or DataFrame objects, Pandas will align\\nindices in the process of performing the operation. This is very convenient when\\nworking with incomplete data, as we'll see in some of the examples that\\nfollow.\"]]], \"180\" [:div [:p/code {:code \"(def A\\n  (tablecloth/dataset\\n   (zipmap [:A :B]\\n           (repeatedly 2 (fn [] (repeatedly 2 #(fm.rand/frand 20)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"88\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"108\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|  :A |   :B |   :C |   :D |\\n|-----|------|------|------|\\n|  20 | 1096 |   54 | 8103 |\\n| 148 | 8103 | 1096 |  148 |\\n|   7 |  148 | 1096 |    1 |\\n\"]]]], \"93\" [:div [:p/code {:code \"^kind/dataset\\n(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"#'scicloj.03-03-operations-in-dataset/DS\"]]]], \"83\" [:div nil [:div nil]], \"188\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 3.10332203 | 8.21758366 | 8.15744972 | 3.61673450 |\\n| 3.05899525 | 4.88347340 | 5.85626459 | 6.29970455 |\\n| 6.42033529 | 9.36911392 | 2.68071151 | 9.78593254 |\\n\"]]]], \"158\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"201\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"141\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"139\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 1.37311101 | 6.68205309 | 2.90432525 | 5.60864925 |\\n| 9.34948921 | 7.92551994 | 0.96674097 | 2.54560208 |\\n| 8.99638653 | 7.94104099 | 7.77766848 | 3.85287833 |\\n\"]]]], \"157\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 0.03301360 | 0.27870333 | 0.04278907 | 0.03779397 |\\n| 0.04637603 | 0.03359830 | 0.04174196 | 0.07532089 |\\n| 0.05305811 | 0.18921662 | 0.12224066 | 0.05340440 |\\n\"]]]], \"185\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"175\" [:div nil [:div [:p/markdown \"Any of the ufuncs discussed in Computation on NumPy Arrays: Universal\\nFunctions can be used in a similar manner.\"]]], \"155\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|             :A |             :B |            :C |            :D |\\n|----------------|----------------|---------------|---------------|\\n| 15394.72041762 |     3.13337315 | 1701.12803457 | 4547.07867941 |\\n|   956.87542460 | 13016.70137462 | 2050.12712336 |   68.44636028 |\\n|   403.13419052 |     5.37764860 |   13.51717032 |  387.75303656 |\\n\"]]]], \"87\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"202\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|          :A |           :B |           :C |          :D |\\n|-------------|--------------|--------------|-------------|\\n| 20.75284556 |  29.57998161 |  26.64862337 |  2.15919189 |\\n|  1.37623871 |  11.90927008 | 252.87844443 |  8.12581898 |\\n| 27.49973370 | 282.05759888 |  21.53364415 | 15.42118313 |\\n\"]]]], \"195\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"118\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"193\" [:div [:p/code {:code \"(def A\\n  (tablecloth/dataset\\n   (zipmap [:A :B]\\n           (repeatedly 2 (fn [] (repeatedly 2 #(fm.rand/frand 20)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"105\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"196\" [:div [:p/code {:code \"(def B\\n  (tablecloth/dataset\\n   (zipmap [:B :A :C]\\n           (repeatedly 3 (fn [] (repeatedly 3 #(fm.rand/frand 20)))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"207\" [:div [:p/code {:code \"(def B\\n  (tablecloth/dataset\\n   (zipmap [:B :A :C]\\n           (repeatedly 3 (fn [] (repeatedly 3 #(fm.rand/frand 20)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"135\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"123\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"82\" [:div nil [:div nil]], \"101\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|   :A |   :B | :C |   :D |\\n|------|------|----|------|\\n|    7 |    7 |  2 | 2980 |\\n|   54 | 8103 |  1 |    2 |\\n| 2980 |  148 | 54 |   20 |\\n\"]]]], \"116\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"89\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"169\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"179\" [:div nil [:div [:p/markdown \"A similar type of alignment takes place for both columns and indices when\\nperforming operations on DataFrames:\"]]], \"156\" [:div nil [:div [:p/markdown \"Or, for a slightly more complex calculation:\"]]], \"96\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"159\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"80\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"162\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"192\" [:div nil [:div [:p/markdown \"A similar type of alignment takes place for both columns and indices when\\nperforming operations on DataFrames:\"]]], \"113\" [:div nil [:div nil]], \"81\" [:div nil [:div nil]], \"167\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"98\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"197\" [:div [:p/code {:code \"^kind/dataset\\nB\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"107\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"115\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n| :A | :B | :C | :D |\\n|----|----|----|----|\\n|  8 |  8 |  7 |  1 |\\n|  7 |  3 |  1 |  3 |\\n|  8 |  5 |  1 |  0 |\\n\"]]]], \"78\" [:div [:p/code {:code \"^kind/dataset\\n(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"111\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"203\" [:div nil [:div [:p/markdown \"Or, for a slightly more complex calculation:\"]]], \"172\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|          :A |           :B |          :C |            :D |\\n|-------------|--------------|-------------|---------------|\\n| 23.18704664 |  15.07046465 | 19.46186644 | 5583.07939292 |\\n|  2.25545344 | 155.59203107 | 16.04785444 |  650.67710160 |\\n|  6.63404534 |  11.45418821 |  7.01029197 |  845.54562425 |\\n\"]]]], \"176\" [:div nil [:div [:p/markdown \"## UFuncs: Index Alignment\"]]], \"119\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"145\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|             :A |            :B |            :C |           :D |\\n|----------------|---------------|---------------|--------------|\\n|     3.94761267 |  797.95570560 |   18.25292328 | 272.77553854 |\\n| 11492.95148433 | 2767.00266587 |    2.62936130 |  12.75090288 |\\n|  8073.85649886 | 2810.28447185 | 2386.70367179 |  47.12851973 |\\n\"]]]], \"128\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"199\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"186\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"152\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"181\" [:div [:p/code {:code \"^kind/dataset\\nA\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [2 2]:\\n\\n|         :A |          :B |\\n|------------|-------------|\\n| 1.80197704 | 13.77572823 |\\n| 0.42002362 |  1.11852860 |\\n\"]]]], \"184\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"100\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|   :A |   :B | :C |   :D |\\n|------|------|----|------|\\n|    7 |    7 |  2 | 2980 |\\n|   54 | 8103 |  1 |    2 |\\n| 2980 |  148 | 54 |   20 |\\n\"]]]], \"106\" [:div [:p/code {:code \"^kind/dataset\\n(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"#'scicloj.03-03-operations-in-dataset/DS\"]]]], \"173\" [:div nil [:div [:p/markdown \"Or, for a slightly more complex calculation:\"]]], \"90\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"190\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 0.10257069 | 0.03873522 | 0.03902076 | 0.08801030 |\\n| 0.10405701 | 0.06518104 | 0.05435374 | 0.05052775 |\\n| 0.04957839 | 0.03397439 | 0.11874082 | 0.03252729 |\\n\"]]]], \"112\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"148\" [:div nil [:div nil]], \"208\" [:div [:p/code {:code \"^kind/dataset\\nB\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 3]:\\n\\n|          :B |          :A |          :C |\\n|-------------|-------------|-------------|\\n| 11.07192421 |  8.75056839 | 17.18922997 |\\n| 18.79831505 |  3.73160219 | 12.44229221 |\\n|  7.27297449 | 13.42042542 | 15.11694050 |\\n\"]]]], \"137\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"140\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 1.37311101 | 6.68205309 | 2.90432525 | 5.60864925 |\\n| 9.34948921 | 7.92551994 | 0.96674097 | 2.54560208 |\\n| 8.99638653 | 7.94104099 | 7.77766848 | 3.85287833 |\\n\"]]]], \"136\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"166\" [:div nil [:div nil]], \"121\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"75\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"194\" [:div [:p/code {:code \"^kind/dataset\\nA\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [2 2]:\\n\\n|          :A |          :B |\\n|-------------|-------------|\\n| 10.29429531 | 12.53773308 |\\n| 14.84104633 |  3.46547723 |\\n\"]]]], \"168\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"76\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"154\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"110\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"97\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"94\" [:div [:p/code {:code \"^kind/dataset\\n(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"#'scicloj.03-03-operations-in-dataset/DS\"]]]], \"174\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 0.10125669 | 0.11733902 | 0.10723076 | 0.03689482 |\\n| 0.39135610 | 0.06306616 | 0.11468250 | 0.04913696 |\\n| 0.16822080 | 0.13054286 | 0.16345551 | 0.04722711 |\\n\"]]]], \"171\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 3.14359379 | 2.71273685 | 2.96845698 | 8.62749577 |\\n| 0.81335104 | 5.04723740 | 2.77557516 | 6.47801352 |\\n| 1.89221478 | 2.43835545 | 1.94737935 | 6.73998213 |\\n\"]]]], \"99\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|   :A |   :B | :C |   :D |\\n|------|------|----|------|\\n|    7 |    7 |  2 | 2980 |\\n|   54 | 8103 |  1 |    2 |\\n| 2980 |  148 | 54 |   20 |\\n\"]]]], \"130\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"200\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"183\" [:div nil [:div nil]], \"205\" [:div nil [:div [:p/markdown \"### Index alignment in DataFrame\"]]], \"122\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"149\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"120\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"206\" [:div nil [:div [:p/markdown \"A similar type of alignment takes place for both columns and indices when\\nperforming operations on DataFrames:\"]]], \"144\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|             :A |            :B |            :C |           :D |\\n|----------------|---------------|---------------|--------------|\\n|     3.94761267 |  797.95570560 |   18.25292328 | 272.77553854 |\\n| 11492.95148433 | 2767.00266587 |    2.62936130 |  12.75090288 |\\n|  8073.85649886 | 2810.28447185 | 2386.70367179 |  47.12851973 |\\n\"]]]], \"134\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"77\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"146\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"84\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"177\" [:div nil [:div [:p/markdown \"For binary operations on two Series or DataFrame objects, Pandas will align\\nindices in the process of performing the operation. This is very convenient when\\nworking with incomplete data, as we'll see in some of the examples that\\nfollow.\"]]], \"125\" [:div nil [:div nil]], \"104\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"95\" [:div [:p/code {:code \"^kind/dataset\\n(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"#'scicloj.03-03-operations-in-dataset/DS\"]]]], \"102\" [:div nil [:div nil]], \"165\" [:div [:p/code {:code \"^kind/dataset\\nA\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"153\" [:div [:p/code {:code \"^kind/dataset\\nDS\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 9.64177990 | 1.14211011 | 7.43904686 | 8.42224026 |\\n| 6.86367321 | 9.47398853 | 7.62565708 | 4.22605038 |\\n| 5.99926949 | 1.68225121 | 2.60396075 | 5.96036863 |\\n\"]]]], \"74\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"142\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"127\" [:div nil [:div nil]], \"109\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"124\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|            :A |           :B |            :C |             :D |\\n|---------------|--------------|---------------|----------------|\\n| 1778.74708860 |   1.08476957 |   19.18942398 |   380.89271876 |\\n| 2868.50817720 | 320.21080656 | 2102.91578879 | 15536.79940612 |\\n| 5099.70853611 |  14.10075796 | 2785.03150680 |    27.42143028 |\\n\"]]]], \"138\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"114\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/irand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"198\" [:div nil [:div nil]], \"133\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"147\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"151\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"182\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"85\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"189\" [:div nil [:div [:p/markdown \"Or, for a slightly more complex calculation:\"]]], \"126\" [:div nil [:div nil]], \"204\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS #(dfn// (dfn/* % Math/PI)))\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|         :A |         :B |         :C |         :D |\\n|------------|------------|------------|------------|\\n| 0.10495982 | 0.09397718 | 0.09696477 | 0.41353231 |\\n| 0.99672990 | 0.12848976 | 0.05753030 | 0.15193452 |\\n| 0.09604495 | 0.05641680 | 0.10369695 | 0.11635230 |\\n\"]]]], \"143\" [:div nil [:div [:p/markdown \"If we apply a NumPy ufunc on either of these objects, the result will be\\nanother Pandas object with the indices preserved:\"]]], \"178\" [:div nil [:div [:p/markdown \"### Index alignment in DataFrame\"]]], \"170\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"131\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"103\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"91\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"161\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"129\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"187\" [:div [:p/code {:code \"(def DS\\n  (tablecloth/dataset\\n   (zipmap [:A :B :C :D]\\n           (repeatedly 4 (fn [] (repeatedly 3 #(fm.rand/frand 10)))))))\", :bg-class \"bg-light\"}] [:div nil]], \"164\" [:div [:p/code {:code \"(def A\\n  (tablecloth/dataset\\n   (zipmap [:A :B]\\n           (repeatedly 2 (fn [] (repeatedly 2 #(fm.rand/frand 20)))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"163\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"86\" [:div nil [:div [:p/markdown \"# Operating on Data in Dataset\"]]], \"92\" [:div [:p/code {:code \"(require\\n  '[tech.v3.dataset :as ds]\\n  '[tech.v3.datatype :as dtype]\\n  '[tech.v3.datatype.functional :as dfn]\\n  '[tablecloth.api :as tablecloth]\\n  '[fastmath.random :as fm.rand])\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\r\\n\"}]]], \"79\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"160\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"150\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]], \"117\" [:div [:p/code {:code \"^kind/dataset\\n(ds/update-elemwise DS dfn/exp)\", :bg-class \"bg-light\"}] [:div [:div {:class \"table table-striped table-hover table-condensed table-responsive\", :style {:height \"400px\"}} [:p/markdown \"_unnamed [3 4]:\\n\\n|   :A |   :B |   :C | :D |\\n|------|------|------|----|\\n| 2980 | 2980 | 1096 |  2 |\\n| 1096 |   20 |    2 | 20 |\\n| 2980 |  148 |    2 |  1 |\\n\"]]]], \"132\" [:div nil [:div [:p/markdown \"One of the essential pieces of NumPy is the ability to perform quick\\nelement-wise operations, both with basic arithmetic (addition, subtraction,\\nmultiplication, etc.) and with more sophisticated operations (trigonometric\\nfunctions, exponential and logarithmic functions, etc.). Pandas inherits much of\\nthis functionality from NumPy, and the ufuncs that we introduced in Computation\\non NumPy Arrays: Universal Functions are key to this.\\n\\nDataset includes a couple useful twists, however: for unary operations like\\nnegation and trigonometric functions, these ufuncs will preserve index and\\ncolumn labels in the output, and for binary operations such as addition and\\nmultiplication, Pandas will automatically align indices when passing the objects\\nto the ufunc. This means that keeping the context of data and combining data\\nfrom different sources–both potentially error-prone tasks with raw NumPy\\narrays–become essentially foolproof ones with Pandas. We will additionally see\\nthat there are well-defined operations between one-dimensional Series structures\\nand two-dimensional DataFrame structures.\"]]]}}");
     document.getElementById("loading").remove();
    </script>
</html>
